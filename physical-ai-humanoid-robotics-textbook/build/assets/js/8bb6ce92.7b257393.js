"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[512],{8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var t=n(6540);const s={},r=t.createContext(s);function o(e){const i=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:i},e.children)}},9919:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Module-2-The-Digital-Twin-Gazebo-&-Unity/chapter1","title":"Chapter 1: Physics Simulation Fundamentals in Gazebo","description":"1.1 Introduction to Gazebo","source":"@site/docs/Module-2-The-Digital-Twin-Gazebo-&-Unity/chapter1.md","sourceDirName":"Module-2-The-Digital-Twin-Gazebo-&-Unity","slug":"/Module-2-The-Digital-Twin-Gazebo-&-Unity/chapter1","permalink":"/docs/Module-2-The-Digital-Twin-Gazebo-&-Unity/chapter1","draft":false,"unlisted":false,"editUrl":"https://github.com/<your-username>/<your-repo>/tree/main/docs/Module-2-The-Digital-Twin-Gazebo-&-Unity/chapter1.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4: Humanoid Modeling with URDF and Xacro","permalink":"/docs/Module-1-The Robotic-Nervous-System/chapter4"},"next":{"title":"Chapter 2: Humanoid Robot Simulation in Gazebo","permalink":"/docs/Module-2-The-Digital-Twin-Gazebo-&-Unity/chapter2"}}');var s=n(4848),r=n(8453);const o={},a="Chapter 1: Physics Simulation Fundamentals in Gazebo",l={},c=[{value:"1.1 Introduction to Gazebo",id:"11-introduction-to-gazebo",level:3},{value:"1.2 Core Physics Concepts",id:"12-core-physics-concepts",level:3},{value:"1.2.1 Gravity and Mass Properties",id:"121-gravity-and-mass-properties",level:4},{value:"1.2.2 Collision Detection and Response",id:"122-collision-detection-and-response",level:4},{value:"1.3 Setting Up Physics Parameters",id:"13-setting-up-physics-parameters",level:3},{value:"1.4 Material and Surface Properties",id:"14-material-and-surface-properties",level:3}];function d(e){const i={code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"chapter-1-physics-simulation-fundamentals-in-gazebo",children:"Chapter 1: Physics Simulation Fundamentals in Gazebo"})}),"\n",(0,s.jsx)(i.h3,{id:"11-introduction-to-gazebo",children:"1.1 Introduction to Gazebo"}),"\n",(0,s.jsx)(i.p,{children:"Gazebo is an open-source robotics simulator that provides a robust environment for testing and validating robot behaviors before deployment in the real world. It bridges the gap between theoretical robotics algorithms and practical implementation by offering:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"High-fidelity physics simulation"})," using ODE (Open Dynamics Engine), Bullet, or Simbody engines"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Sensor simulation"})," including cameras, LiDAR, and IMUs"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Real-time rendering"})," with ray-tracing capabilities"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Multi-robot support"})," for complex scenarios"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"12-core-physics-concepts",children:"1.2 Core Physics Concepts"}),"\n",(0,s.jsx)(i.h4,{id:"121-gravity-and-mass-properties",children:"1.2.1 Gravity and Mass Properties"}),"\n",(0,s.jsx)(i.p,{children:"In Gazebo, gravitational forces are simulated to match real-world conditions. Every object in the simulation has:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Property"}),(0,s.jsx)(i.th,{children:"Description"}),(0,s.jsx)(i.th,{children:"Unit"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Mass"}),(0,s.jsx)(i.td,{children:"Object's resistance to acceleration"}),(0,s.jsx)(i.td,{children:"kg"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Inertia Tensor"}),(0,s.jsx)(i.td,{children:"Resistance to rotational motion"}),(0,s.jsx)(i.td,{children:"kg\xb7m\xb2"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Center of Mass"}),(0,s.jsx)(i.td,{children:"Point where total mass concentrates"}),(0,s.jsx)(i.td,{children:"m"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Friction Coefficient"}),(0,s.jsx)(i.td,{children:"Resistance to sliding motion"}),(0,s.jsx)(i.td,{children:"dimensionless"})]})]})]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:"<inertial>\r\n  <mass>10.0</mass>\r\n  <inertia>\r\n    <ixx>0.1</ixx>\r\n    <iyy>0.1</iyy>\r\n    <izz>0.1</izz>\r\n  </inertia>\r\n</inertial>\n"})}),"\n",(0,s.jsx)(i.h4,{id:"122-collision-detection-and-response",children:"1.2.2 Collision Detection and Response"}),"\n",(0,s.jsx)(i.p,{children:"Gazebo implements continuous collision detection to prevent objects from passing through each other. The collision pipeline consists of:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Broad Phase"}),": Quickly eliminates pairs of objects that cannot collide"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Narrow Phase"}),": Precise calculation of collision points and normals"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Constraint Solver"}),": Computes impulses to prevent penetration"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"13-setting-up-physics-parameters",children:"1.3 Setting Up Physics Parameters"}),"\n",(0,s.jsx)(i.p,{children:"Physics engines in Gazebo are configured through the world file with parameters such as:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Time Step"}),": Duration of each simulation iteration (typically 0.001-0.01 seconds)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Gravity Vector"}),": Default is (0, 0, -9.81) m/s\xb2"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Iterations"}),": Number of solver iterations per step"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Real-time Factor"}),": Ratio of simulation speed to wall-clock time"]}),"\n"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'<physics name="default_physics" default="0" type="ode">\r\n  <max_step_size>0.001</max_step_size>\r\n  <real_time_factor>1.0</real_time_factor>\r\n  <real_time_update_rate>1000</real_time_update_rate>\r\n</physics>\n'})}),"\n",(0,s.jsx)(i.h3,{id:"14-material-and-surface-properties",children:"1.4 Material and Surface Properties"}),"\n",(0,s.jsx)(i.p,{children:"Surface interactions in Gazebo are defined through material properties that affect how objects behave during collisions:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Static Friction"}),": Prevents sliding until a threshold force is exceeded"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Dynamic Friction"}),": Occurs when objects are sliding relative to each other"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Restitution"}),": Coefficient determining bounce after collision (0 = no bounce, 1 = perfect bounce)"]}),"\n"]}),"\n",(0,s.jsx)(i.hr,{})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);