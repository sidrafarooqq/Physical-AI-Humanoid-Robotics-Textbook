"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[287],{3760:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>_,frontMatter:()=>s,metadata:()=>t,toc:()=>i});const t=JSON.parse('{"id":"Module-4-Vision-Language-Action-VLA/chapter3","title":"Chapter 3: From Planning to Execution - ROS 2 Action Integration","description":"3.1 ROS 2 Actions Architecture","source":"@site/docs/Module-4-Vision-Language-Action-VLA/chapter3.md","sourceDirName":"Module-4-Vision-Language-Action-VLA","slug":"/Module-4-Vision-Language-Action-VLA/chapter3","permalink":"/docs/Module-4-Vision-Language-Action-VLA/chapter3","draft":false,"unlisted":false,"editUrl":"https://github.com/<your-username>/<your-repo>/tree/main/docs/Module-4-Vision-Language-Action-VLA/chapter3.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Cognitive Planning - LLMs Translating Language to Action","permalink":"/docs/Module-4-Vision-Language-Action-VLA/chapter2"},"next":{"title":"Chapter 4: Capstone Project - The Autonomous Humanoid","permalink":"/docs/Module-4-Vision-Language-Action-VLA/chapter4"}}');var o=r(4848),a=r(8453);const s={},l="Chapter 3: From Planning to Execution - ROS 2 Action Integration",c={},i=[{value:"3.1 ROS 2 Actions Architecture",id:"31-ros-2-actions-architecture",level:3},{value:"3.1.1 Action-Based Task Execution",id:"311-action-based-task-execution",level:4},{value:"3.2 Plan Execution Pipeline",id:"32-plan-execution-pipeline",level:3},{value:"3.2.1 Complete Execution Loop",id:"321-complete-execution-loop",level:4}];function u(e){const n={code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",hr:"hr",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"chapter-3-from-planning-to-execution---ros-2-action-integration",children:"Chapter 3: From Planning to Execution - ROS 2 Action Integration"})}),"\n",(0,o.jsx)(n.h3,{id:"31-ros-2-actions-architecture",children:"3.1 ROS 2 Actions Architecture"}),"\n",(0,o.jsx)(n.h4,{id:"311-action-based-task-execution",children:"3.1.1 Action-Based Task Execution"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'# ROS 2 Action Server for Robot Tasks\r\nimport rclpy\r\nfrom rclpy.action import ActionServer\r\nfrom rclpy.node import Node\r\nfrom rclpy.executors import MultiThreadedExecutor\r\n\r\n# Define custom action messages\r\nclass ExecuteRobotTask(Action):\r\n    """Custom action for robot task execution"""\r\n    \r\n    class Goal:\r\n        action_name: str\r\n        parameters: Dict[str, str]\r\n    \r\n    class Result:\r\n        success: bool\r\n        message: str\r\n    \r\n    class Feedback:\r\n        progress: float  # 0.0 to 1.0\r\n        status: str\r\n\r\nclass RobotTaskExecutor(Node):\r\n    """Execute planned actions via ROS 2 actions"""\r\n    \r\n    def __init__(self):\r\n        super().__init__(\'robot_task_executor\')\r\n        \r\n        # Create action server\r\n        self._action_server = ActionServer(\r\n            self,\r\n            ExecuteRobotTask,\r\n            \'execute_task\',\r\n            self.execute_callback\r\n        )\r\n        \r\n        # Action clients for robot capabilities\r\n        self.nav_client = ActionClient(self, NavigateToPose, \'/navigate_to_pose\')\r\n        self.manipulation_client = ActionClient(\r\n            self, \r\n            PickPlace, \r\n            \'/pick_place\'\r\n        )\r\n        \r\n        self.get_logger().info("\ud83e\udd16 Robot Task Executor initialized")\r\n    \r\n    async def execute_callback(self, goal_handle):\r\n        """Execute a single planned action"""\r\n        \r\n        goal = goal_handle.request\r\n        action_name = goal.action_name\r\n        parameters = goal.parameters\r\n        \r\n        self.get_logger().info(f"Executing: {action_name}")\r\n        \r\n        try:\r\n            # Execute based on action type\r\n            if action_name == \'navigate\':\r\n                success = await self._execute_navigate(\r\n                    parameters[\'destination\'],\r\n                    goal_handle\r\n                )\r\n            \r\n            elif action_name == \'pick_up\':\r\n                success = await self._execute_pick_up(\r\n                    parameters[\'object\'],\r\n                    goal_handle\r\n                )\r\n            \r\n            elif action_name == \'place\':\r\n                success = await self._execute_place(\r\n                    parameters[\'object\'],\r\n                    parameters[\'location\'],\r\n                    goal_handle\r\n                )\r\n            \r\n            elif action_name == \'look_for\':\r\n                success = await self._execute_look_for(\r\n                    parameters[\'target\'],\r\n                    goal_handle\r\n                )\r\n            \r\n            else:\r\n                success = False\r\n                self.get_logger().warn(f"Unknown action: {action_name}")\r\n            \r\n            # Set result\r\n            if success:\r\n                goal_handle.succeed()\r\n                result = ExecuteRobotTask.Result()\r\n                result.success = True\r\n                result.message = f"Successfully executed {action_name}"\r\n            else:\r\n                goal_handle.abort()\r\n                result = ExecuteRobotTask.Result()\r\n                result.success = False\r\n                result.message = f"Failed to execute {action_name}"\r\n            \r\n            return result\r\n            \r\n        except Exception as e:\r\n            self.get_logger().error(f"Action execution error: {e}")\r\n            goal_handle.abort()\r\n            result = ExecuteRobotTask.Result()\r\n            result.success = False\r\n            result.message = str(e)\r\n            return result\r\n    \r\n    async def _execute_navigate(self, destination: str, \r\n                               goal_handle) -> bool:\r\n        """Navigate to destination"""\r\n        \r\n        # Convert destination name to coordinates\r\n        coords = self._location_to_coordinates(destination)\r\n        \r\n        if coords is None:\r\n            return False\r\n        \r\n        # Create navigation goal\r\n        nav_goal = NavigateToPose.Goal()\r\n        nav_goal.pose.pose.position.x = coords[0]\r\n        nav_goal.pose.pose.position.y = coords[1]\r\n        \r\n        # Wait for nav2 server\r\n        if not self.nav_client.wait_for_server(timeout_sec=5.0):\r\n            return False\r\n        \r\n        # Send goal\r\n        send_goal_future = self.nav_client.send_goal_async(nav_goal)\r\n        \r\n        # Wait for result\r\n        rclpy.spin_until_future_complete(self, send_goal_future)\r\n        goal_result = send_goal_future.result()\r\n        \r\n        if goal_result is None:\r\n            return False\r\n        \r\n        # Get result\r\n        get_result_future = goal_result.get_result_async()\r\n        rclpy.spin_until_future_complete(self, get_result_future)\r\n        \r\n        # Update feedback\r\n        feedback = ExecuteRobotTask.Feedback()\r\n        feedback.progress = 1.0\r\n        feedback.status = f"Navigated to {destination}"\r\n        goal_handle.publish_feedback(feedback)\r\n        \r\n        return get_result_future.result().success\r\n    \r\n    async def _execute_pick_up(self, obj: str, goal_handle) -> bool:\r\n        """Pick up object"""\r\n        \r\n        # Use vision to locate object\r\n        object_pose = await self._locate_object(obj)\r\n        \r\n        if object_pose is None:\r\n            self.get_logger().warn(f"Object \'{obj}\' not found")\r\n            return False\r\n        \r\n        # Create manipulation goal\r\n        manip_goal = PickPlace.Goal()\r\n        manip_goal.object_name = obj\r\n        manip_goal.target_pose = object_pose\r\n        manip_goal.action = "pick_up"\r\n        \r\n        # Send goal\r\n        send_goal_future = self.manipulation_client.send_goal_async(manip_goal)\r\n        rclpy.spin_until_future_complete(self, send_goal_future)\r\n        \r\n        goal_result = send_goal_future.result()\r\n        if goal_result is None:\r\n            return False\r\n        \r\n        # Update feedback\r\n        feedback = ExecuteRobotTask.Feedback()\r\n        feedback.progress = 1.0\r\n        feedback.status = f"Picked up {obj}"\r\n        goal_handle.publish_feedback(feedback)\r\n        \r\n        return True\r\n    \r\n    async def _execute_place(self, obj: str, location: str, \r\n                            goal_handle) -> bool:\r\n        """Place object at location"""\r\n        \r\n        # Get placement coordinates\r\n        placement_coords = self._location_to_coordinates(location)\r\n        \r\n        if placement_coords is None:\r\n            return False\r\n        \r\n        # Create manipulation goal\r\n        manip_goal = PickPlace.Goal()\r\n        manip_goal.object_name = obj\r\n        manip_goal.target_pose = placement_coords\r\n        manip_goal.action = "place"\r\n        \r\n        # Send goal\r\n        send_goal_future = self.manipulation_client.send_goal_async(manip_goal)\r\n        rclpy.spin_until_future_complete(self, send_goal_future)\r\n        \r\n        feedback = ExecuteRobotTask.Feedback()\r\n        feedback.progress = 1.0\r\n        feedback.status = f"Placed {obj} at {location}"\r\n        goal_handle.publish_feedback(feedback)\r\n        \r\n        return True\r\n    \r\n    async def _execute_look_for(self, target: str, goal_handle) -> bool:\r\n        """Search for object"""\r\n        \r\n        target_pose = await self._locate_object(target)\r\n        \r\n        feedback = ExecuteRobotTask.Feedback()\r\n        feedback.progress = 1.0\r\n        feedback.status = f"Found {target}" if target_pose else f"Could not find {target}"\r\n        goal_handle.publish_feedback(feedback)\r\n        \r\n        return target_pose is not None\r\n    \r\n    def _location_to_coordinates(self, location: str):\r\n        """Convert location name to coordinates"""\r\n        location_map = {\r\n            \'living_room\': (0.0, 0.0),\r\n            \'kitchen\': (5.0, 0.0),\r\n            \'bedroom\': (0.0, 5.0),\r\n            \'bathroom\': (5.0, 5.0),\r\n            \'hallway\': (2.5, 2.5)\r\n        }\r\n        return location_map.get(location.lower())\r\n    \r\n    async def _locate_object(self, obj: str):\r\n        """Use vision to locate object"""\r\n        # This would integrate with vision/detection modules\r\n        pass\n'})}),"\n",(0,o.jsx)(n.h3,{id:"32-plan-execution-pipeline",children:"3.2 Plan Execution Pipeline"}),"\n",(0,o.jsx)(n.h4,{id:"321-complete-execution-loop",children:"3.2.1 Complete Execution Loop"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class PlanExecutor(Node):\r\n    """Execute complete plans from LLM"""\r\n    \r\n    def __init__(self):\r\n        super().__init__(\'plan_executor\')\r\n        \r\n        self.planner = CognitivePlanner()\r\n        self.task_executor = RobotTaskExecutor()\r\n        self.executor = MultiThreadedExecutor()\r\n        \r\n        # Subscribe to voice commands\r\n        self.command_subscription = self.create_subscription(\r\n            String,\r\n            \'/robot/voice_command\',\r\n            self.voice_command_callback,\r\n            10\r\n        )\r\n        \r\n        # Publish execution status\r\n        self.status_publisher = self.create_publisher(\r\n            String,\r\n            \'/robot/execution_status\',\r\n            10\r\n        )\r\n    \r\n    def voice_command_callback(self, msg: String):\r\n        """Handle incoming voice command"""\r\n        \r\n        command = msg.data\r\n        self.get_logger().info(f"\ud83d\udde3\ufe0f Voice command: {command}")\r\n        \r\n        # Generate plan\r\n        self.get_logger().info("\ud83e\udde0 Generating plan...")\r\n        plan = self.planner.plan_task(command)\r\n        \r\n        # Validate plan\r\n        is_valid, reason = self.planner.validate_plan(plan)\r\n        \r\n        if not is_valid:\r\n            self.get_logger().error(f"Invalid plan: {reason}")\r\n            status_msg = String()\r\n            status_msg.data = f"Error: Invalid plan - {reason}"\r\n            self.status_publisher.publish(status_msg)\r\n            return\r\n        \r\n        self.get_logger().info(f"Plan validated with {len(plan)} steps")\r\n        \r\n        # Execute plan\r\n        self.get_logger().info("\u26a1 Executing plan...")\r\n        success, message = self.execute_plan(plan)\r\n        \r\n        # Publish result\r\n        status_msg = String()\r\n        status_msg.data = f"Execution {\'successful\' if success else \'failed\'}: {message}"\r\n        self.status_publisher.publish(status_msg)\r\n        \r\n        if success:\r\n            self.get_logger().info("\u2705 Task completed successfully!")\r\n        else:\r\n            self.get_logger().error(f"\u274c Task failed: {message}")\r\n    \r\n    def execute_plan(self, plan: List[Dict]) -> Tuple[bool, str]:\r\n        """Execute a complete plan"""\r\n        \r\n        for step_idx, step in enumerate(plan):\r\n            self.get_logger().info(\r\n                f"Step {step_idx + 1}/{len(plan)}: {step[\'action\']}"\r\n            )\r\n            \r\n            try:\r\n                # Create and execute action\r\n                success = self._execute_single_action(step)\r\n                \r\n                if not success:\r\n                    return False, f"Failed at step {step_idx + 1}"\r\n                \r\n            except Exception as e:\r\n                self.get_logger().error(f"Exception in step {step_idx}: {e}")\r\n                return False, str(e)\r\n        \r\n        return True, "All steps completed"\r\n    \r\n    def _execute_single_action(self, action: Dict) -> bool:\r\n        """Execute single action from plan"""\r\n        # Implementation delegates to action servers\r\n        pass\n'})}),"\n",(0,o.jsx)(n.hr,{})]})}function _(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>l});var t=r(6540);const o={},a=t.createContext(o);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);