"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[739],{8453:(n,e,a)=>{a.d(e,{R:()=>o,x:()=>s});var t=a(6540);const r={},i=t.createContext(r);function o(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),t.createElement(i.Provider,{value:e},n.children)}},8772:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Module-3-The-AI-Robot-Brain-NVIDIA-Isaac\u2122/chapter3","title":"Chapter 3: Path Planning for Bipedal Humanoid Movement","description":"3.1 Introduction to Nav2 (Navigation 2)","source":"@site/docs/Module-3-The-AI-Robot-Brain-NVIDIA-Isaac\u2122/chapter3.md","sourceDirName":"Module-3-The-AI-Robot-Brain-NVIDIA-Isaac\u2122","slug":"/Module-3-The-AI-Robot-Brain-NVIDIA-Isaac\u2122/chapter3","permalink":"/docs/Module-3-The-AI-Robot-Brain-NVIDIA-Isaac\u2122/chapter3","draft":false,"unlisted":false,"editUrl":"https://github.com/<your-username>/<your-repo>/tree/main/docs/Module-3-The-AI-Robot-Brain-NVIDIA-Isaac\u2122/chapter3.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Isaac ROS - Hardware-Accelerated Vision Systems","permalink":"/docs/Module-3-The-AI-Robot-Brain-NVIDIA-Isaac\u2122/chapter2"},"next":{"title":"Chapter 4: Integration and End-to-End AI-Robot System","permalink":"/docs/Module-3-The-AI-Robot-Brain-NVIDIA-Isaac\u2122/chapter4"}}');var r=a(4848),i=a(8453);const o={},s="Chapter 3: Path Planning for Bipedal Humanoid Movement",l={},c=[{value:"3.1 Introduction to Nav2 (Navigation 2)",id:"31-introduction-to-nav2-navigation-2",level:3},{value:"3.2 Bipedal Navigation Challenges",id:"32-bipedal-navigation-challenges",level:3},{value:"3.2.1 Kinematic Constraints",id:"321-kinematic-constraints",level:4},{value:"3.2.2 Dynamic Balance Requirement",id:"322-dynamic-balance-requirement",level:4},{value:"3.3 Nav2 Architecture for Humanoids",id:"33-nav2-architecture-for-humanoids",level:3},{value:"3.3.1 Costmap and Environment Representation",id:"331-costmap-and-environment-representation",level:4},{value:"3.3.2 Planners for Bipedal Motion",id:"332-planners-for-bipedal-motion",level:4},{value:"3.4 Gait Adaptation and Step Planning",id:"34-gait-adaptation-and-step-planning",level:3},{value:"3.4.1 Gait Types for Humanoid Navigation",id:"341-gait-types-for-humanoid-navigation",level:4},{value:"3.4.2 Step Footprint Generation",id:"342-step-footprint-generation",level:4},{value:"3.4.3 Navigation Feedback and Control Loop",id:"343-navigation-feedback-and-control-loop",level:4}];function d(n){const e={code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"chapter-3-path-planning-for-bipedal-humanoid-movement",children:"Chapter 3: Path Planning for Bipedal Humanoid Movement"})}),"\n",(0,r.jsx)(e.h3,{id:"31-introduction-to-nav2-navigation-2",children:"3.1 Introduction to Nav2 (Navigation 2)"}),"\n",(0,r.jsx)(e.p,{children:"Nav2 (Navigation 2) is the ROS 2 navigation framework that provides:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Path Planning"}),": Calculating collision-free routes through environments"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Behavior Trees"}),": Flexible robot behavior coordination"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Recovery Behaviors"}),": Handling navigation failures gracefully"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Cost Maps"}),": Spatial representations of obstacles and traversability"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"32-bipedal-navigation-challenges",children:"3.2 Bipedal Navigation Challenges"}),"\n",(0,r.jsx)(e.p,{children:"Humanoid robots present unique navigation challenges compared to wheeled robots:"}),"\n",(0,r.jsx)(e.h4,{id:"321-kinematic-constraints",children:"3.2.1 Kinematic Constraints"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Wheeled Robot:\r\n- Instantaneous rotation possible\r\n- Omnidirectional movement (some types)\r\n\r\nBipedal Humanoid:\r\n- Forward walking is primary mode\r\n- Lateral stepping more energy-expensive\r\n- Rotation requires multi-step sequences\r\n- Balance constraints limit acceleration\n"})}),"\n",(0,r.jsx)(e.h4,{id:"322-dynamic-balance-requirement",children:"3.2.2 Dynamic Balance Requirement"}),"\n",(0,r.jsx)(e.p,{children:"Bipedal walking requires continuous balance maintenance:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),": The point where vertical reaction force acts"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Stability Region"}),": Area where ZMP must remain for stability"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Center of Mass Trajectory"}),": Pre-planned to maintain stability"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'# Example: Zero Moment Point Calculation\r\nimport numpy as np\r\n\r\ndef calculate_zmp(center_of_mass, velocity, acceleration, mass, g=9.81):\r\n    """\r\n    Calculate Zero Moment Point for bipedal stability\r\n    \r\n    Args:\r\n        center_of_mass: [x, y, z] CoM position in meters\r\n        velocity: [vx, vy, vz] CoM velocity in m/s\r\n        acceleration: [ax, ay, az] CoM acceleration in m/s\xb2\r\n        mass: Robot mass in kg\r\n    \r\n    Returns:\r\n        zmp: [x, y] ZMP position in horizontal plane\r\n    """\r\n    g = 9.81\r\n    z_com = center_of_mass[2]\r\n    \r\n    # ZMP calculation using inverted pendulum model\r\n    zmp_x = center_of_mass[0] - (velocity[2] * velocity[0]) / g - (acceleration[0] * z_com) / g\r\n    zmp_y = center_of_mass[1] - (velocity[2] * velocity[1]) / g - (acceleration[1] * z_com) / g\r\n    \r\n    return np.array([zmp_x, zmp_y])\n'})}),"\n",(0,r.jsx)(e.h3,{id:"33-nav2-architecture-for-humanoids",children:"3.3 Nav2 Architecture for Humanoids"}),"\n",(0,r.jsx)(e.h4,{id:"331-costmap-and-environment-representation",children:"3.3.1 Costmap and Environment Representation"}),"\n",(0,r.jsx)(e.p,{children:"Nav2 uses costmaps to represent robot's understanding of traversable space:"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Static Costmap:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Pre-loaded maps from SLAM or survey data"}),"\n",(0,r.jsx)(e.li,{children:"Represents known static obstacles"}),"\n",(0,r.jsx)(e.li,{children:"High confidence but may become stale"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Dynamic Costmap:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Updated from sensor data in real-time"}),"\n",(0,r.jsx)(e.li,{children:"Detects dynamic obstacles (humans, moving objects)"}),"\n",(0,r.jsx)(e.li,{children:"Combined with static map for comprehensive view"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# Example: Nav2 Costmap Configuration\r\ncostmap_config = {\r\n    'global_frame': 'map',\r\n    'robot_base_frame': 'base_link',\r\n    'update_frequency': 10.0,      # Hz\r\n    'publish_frequency': 5.0,       # Hz\r\n    'width': 100,                   # cells\r\n    'height': 100,\r\n    'resolution': 0.05,             # meters per cell\r\n    'inflation_radius': 0.5,        # meters\r\n    'layers': {\r\n        'static': {'map_topic': '/map'},\r\n        'obstacles': {'sensor_topic': '/lidar/scan'},\r\n        'inflation': {'cost_scaling_factor': 10.0}\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"332-planners-for-bipedal-motion",children:"3.3.2 Planners for Bipedal Motion"}),"\n",(0,r.jsx)(e.p,{children:"Nav2 supports multiple planning algorithms optimized for different scenarios:"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsxs)(e.em,{children:[(0,r.jsx)(e.em,{children:"Theta"})," (Any-angle Path Planning):"]}),"*"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Produces natural paths without grid artifacts"}),"\n",(0,r.jsx)(e.li,{children:"Suitable for bipedal step placement"}),"\n",(0,r.jsx)(e.li,{children:"Time-optimal trajectory generation"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsxs)(e.em,{children:[(0,r.jsx)(e.em,{children:"Hybrid-A"})," (Kinodynamic Planning):"]}),"*"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Respects vehicle dynamics and constraints"}),"\n",(0,r.jsx)(e.li,{children:"Generates feasible bipedal walking sequences"}),"\n",(0,r.jsx)(e.li,{children:"Handles non-holonomic constraints"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# Example: Configuring Theta* Planner\r\ntheta_star_params = {\r\n    'inflation_cost_scaling_factor': 3.0,\r\n    'cost_travel_multiplier': 2.0,\r\n    'minimum_path_length': 0.1,\r\n    'max_planning_time': 5.0,          # seconds\r\n    'angle_quantization_divisions': 72  # 5-degree resolution\r\n}\r\n\r\n# For bipedal robots, prefer:\r\nplanner_type = 'nav2_theta_star_planner::ThetaStarPlanner'\n"})}),"\n",(0,r.jsx)(e.h3,{id:"34-gait-adaptation-and-step-planning",children:"3.4 Gait Adaptation and Step Planning"}),"\n",(0,r.jsx)(e.h4,{id:"341-gait-types-for-humanoid-navigation",children:"3.4.1 Gait Types for Humanoid Navigation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Walking Gait (0.3-1.5 m/s):\r\n- Natural bipedal walking motion\r\n- Energy-efficient for sustained movement\r\n- Good stability margin\r\n\r\nRunning Gait (1.5-3.0 m/s):\r\n- Dynamic phases with flight\r\n- Higher energy consumption\r\n- Reduced stability margin\r\n\r\nTurning and Spinning:\r\n- Multi-step rotation sequences\r\n- Coordinated hip and foot placement\r\n- Smooth curvature following\n"})}),"\n",(0,r.jsx)(e.h4,{id:"342-step-footprint-generation",children:"3.4.2 Step Footprint Generation"}),"\n",(0,r.jsx)(e.p,{children:"Steps must be placed on collision-free, stable surfaces:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'# Example: Footstep Planning for Humanoids\r\nclass FootstepPlanner:\r\n    def __init__(self, max_step_length=0.5, max_turn_angle=30):\r\n        self.max_step_length = max_step_length\r\n        self.max_turn_angle = max_turn_angle\r\n        \r\n    def plan_footsteps(self, start_pose, goal_pose, costmap):\r\n        """\r\n        Generate sequence of footsteps to reach goal\r\n        \r\n        Args:\r\n            start_pose: [x, y, theta] initial humanoid position\r\n            goal_pose: [x, y, theta] desired position\r\n            costmap: 2D occupancy grid\r\n        \r\n        Returns:\r\n            footsteps: List of [x, y, theta] for each step\r\n        """\r\n        footsteps = []\r\n        current_pose = start_pose\r\n        \r\n        while not self._reached_goal(current_pose, goal_pose):\r\n            # Generate candidate next steps\r\n            candidates = self._generate_step_candidates(current_pose, goal_pose)\r\n            \r\n            # Select best step (collision-free, stable surface)\r\n            next_step = self._select_best_step(candidates, costmap)\r\n            \r\n            footsteps.append(next_step)\r\n            current_pose = next_step\r\n        \r\n        return footsteps\r\n    \r\n    def _generate_step_candidates(self, current_pose, goal_pose, num_candidates=8):\r\n        """Generate candidate footsteps at different angles"""\r\n        candidates = []\r\n        for angle in np.linspace(0, 2*np.pi, num_candidates):\r\n            x = current_pose[0] + self.max_step_length * np.cos(angle)\r\n            y = current_pose[1] + self.max_step_length * np.sin(angle)\r\n            candidates.append([x, y, angle])\r\n        return candidates\r\n    \r\n    def _select_best_step(self, candidates, costmap):\r\n        """Select step with best cost (closeness to goal + stability)"""\r\n        best_candidate = None\r\n        best_cost = float(\'inf\')\r\n        \r\n        for candidate in candidates:\r\n            cost = self._evaluate_step_cost(candidate, costmap)\r\n            if cost < best_cost:\r\n                best_cost = cost\r\n                best_candidate = candidate\r\n        \r\n        return best_candidate\r\n    \r\n    def _evaluate_step_cost(self, step, costmap):\r\n        """Evaluate step based on collision and stability"""\r\n        # Check if foot placement is collision-free\r\n        if not self._is_collision_free(step, costmap):\r\n            return float(\'inf\')\r\n        \r\n        # Evaluate stability (surface normal, friction, etc.)\r\n        stability_score = self._calculate_stability(step)\r\n        \r\n        return stability_score\n'})}),"\n",(0,r.jsx)(e.h4,{id:"343-navigation-feedback-and-control-loop",children:"3.4.3 Navigation Feedback and Control Loop"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# Nav2 Controller Loop for Bipedal Robots\r\nimport rclpy\r\nfrom nav2_simple_commander.robot_navigator import BasicNavigator\r\n\r\nrclpy.init()\r\nnav = BasicNavigator()\r\n\r\n# Wait for nav to be ready\r\nnav.waitUntilNav2Active()\r\n\r\n# Set goal\r\ngoal_pose = [10.0, 5.0, 0.0]  # [x, y, theta]\r\nnav.goToPose(goal_pose)\r\n\r\n# Monitor navigation\r\nwhile not nav.isTaskComplete():\r\n    feedback = nav.getFeedback()\r\n    \r\n    # Adapt gait if necessary based on feedback\r\n    if feedback.navigation_time > 30.0:  # Timeout\r\n        nav.cancelTask()\r\n        break\r\n    \r\n    # Update step plan based on dynamic obstacles\r\n    update_footstep_plan(feedback.current_pose)\n"})}),"\n",(0,r.jsx)(e.hr,{})]})}function p(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);