"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[282],{693:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"Module-1-The Robotic-Nervous-System/chapter2","title":"Chapter 2: ROS 2 Communication Primitives","description":"The Language of Robots: Nodes, Topics, Services, and Actions","source":"@site/docs/Module-1-The Robotic-Nervous-System/chapter2.md","sourceDirName":"Module-1-The Robotic-Nervous-System","slug":"/Module-1-The Robotic-Nervous-System/chapter2","permalink":"/docs/Module-1-The Robotic-Nervous-System/chapter2","draft":false,"unlisted":false,"editUrl":"https://github.com/<your-username>/<your-repo>/tree/main/docs/Module-1-The Robotic-Nervous-System/chapter2.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: Foundations of ROS 2 Architecture","permalink":"/docs/Module-1-The Robotic-Nervous-System/chapter1"},"next":{"title":"Chapter 3: Implementing Your First ROS 2 System","permalink":"/docs/Module-1-The Robotic-Nervous-System/chapter3"}}');var i=s(4848),t=s(8453);const r={},c="Chapter 2: ROS 2 Communication Primitives",a={},d=[{value:"The Language of Robots: Nodes, Topics, Services, and Actions",id:"the-language-of-robots-nodes-topics-services-and-actions",level:2},{value:"Nodes and the Computation Graph",id:"nodes-and-the-computation-graph",level:3},{value:"Topics: Continuous Data Streams",id:"topics-continuous-data-streams",level:3},{value:"Services: Request-Response Communication",id:"services-request-response-communication",level:3},{value:"Actions: Long-Running Tasks with Feedback",id:"actions-long-running-tasks-with-feedback",level:3},{value:"Communication Comparison",id:"communication-comparison",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-2-ros-2-communication-primitives",children:"Chapter 2: ROS 2 Communication Primitives"})}),"\n",(0,i.jsx)(n.h2,{id:"the-language-of-robots-nodes-topics-services-and-actions",children:"The Language of Robots: Nodes, Topics, Services, and Actions"}),"\n",(0,i.jsx)(n.p,{children:'At its heart, ROS 2 is about communication. Imagine a robot\'s "brain" as a collection of independent programs, each focused on a specific task: one node processes camera data, another controls motors, another plans movements. These are the building blocks of ROS 2 systems.'}),"\n",(0,i.jsx)(n.h3,{id:"nodes-and-the-computation-graph",children:"Nodes and the Computation Graph"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"node"})," is an executable that performs a specific function in the ROS 2 system. Nodes are isolated processes that communicate with other nodes through ROS 2's middleware. This isolation provides robustness\u2014if one node crashes, others continue functioning."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"computation graph"})," is the network of all active nodes and the connections between them. Visualizing this graph using tools like ",(0,i.jsx)(n.code,{children:"rqt_graph"})," helps you understand your robotic system's architecture."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Camera Node \u2192 Image Processing \u2192 Motion Planning \u2192 Motor Control Node\r\n   \u2193              \u2193                    \u2193\r\n/camera/image  /processed/img    /trajectory\n"})}),"\n",(0,i.jsx)(n.h3,{id:"topics-continuous-data-streams",children:"Topics: Continuous Data Streams"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Topics"})," are named channels over which nodes exchange data asynchronously. A node ",(0,i.jsx)(n.strong,{children:"publishes"})," messages to a topic, while other nodes ",(0,i.jsx)(n.strong,{children:"subscribe"})," to that same topic to receive those messages."]}),"\n",(0,i.jsx)(n.p,{children:"Characteristics of topics:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"One-to-Many"}),": One publisher, many subscribers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Asynchronous"}),": Publishers don't wait for subscribers to receive data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Continuous"}),": Suitable for sensor data, status updates, control commands"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Loosely Coupled"}),": Publisher and subscriber don't need to know each other"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Use case: A humanoid's camera node publishes images at 30 Hz. Multiple nodes (object detection, motion planning, visualization) can subscribe independently."}),"\n",(0,i.jsx)(n.h3,{id:"services-request-response-communication",children:"Services: Request-Response Communication"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Services"})," implement synchronous, request-response communication. A client node sends a request to a server node and waits for a response. The client is blocked until the server responds."]}),"\n",(0,i.jsx)(n.p,{children:"Characteristics of services:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Two-way Communication"}),": Request and response"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Synchronous"}),": Client waits for response"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Short-lived"}),": Meant for quick operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"One-to-One"}),": Typically one server, multiple clients"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Use case: A humanoid's arm controller provides a service ",(0,i.jsx)(n.code,{children:"/move_arm_to_pose"})," that clients can call to request a specific arm position."]}),"\n",(0,i.jsx)(n.h3,{id:"actions-long-running-tasks-with-feedback",children:"Actions: Long-Running Tasks with Feedback"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Actions"})," are designed for long-running, goal-oriented tasks that provide continuous feedback. An action client sends a ",(0,i.jsx)(n.strong,{children:"goal"})," to an action server, which then works toward achieving that goal while providing periodic ",(0,i.jsx)(n.strong,{children:"feedback"})," and finally a ",(0,i.jsx)(n.strong,{children:"result"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Characteristics of actions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Goal-Oriented"}),": Client specifies desired outcome"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feedback"}),": Server provides progress updates"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cancellable"}),": Client can cancel an ongoing goal"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Result-Driven"}),": Final outcome returned to client"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Use case: A humanoid receives an action goal ",(0,i.jsx)(n.code,{children:"/navigate_to_kitchen"}),". The action server provides feedback every 0.5 seconds about distance traveled and ultimately returns whether the navigation succeeded."]}),"\n",(0,i.jsx)(n.h3,{id:"communication-comparison",children:"Communication Comparison"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Topic:   Sensor1 \u2192(continuous stream)\u2192 [Filter] \u2192 [Planner]\r\nService: UI \u2192(request: "Get status")\u2192 StatusServer \u2192(response: "Ready") \u2192 UI\r\nAction:  Client \u2192(Goal: "Walk 5m") \u2192 ActionServer \u2192(Feedback: "1m, 2m...") \u2192 Result\n'})}),"\n",(0,i.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var o=s(6540);const i={},t=o.createContext(i);function r(e){const n=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);